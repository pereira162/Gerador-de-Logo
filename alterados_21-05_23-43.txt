Data de exportação: 21/05 às 23:43
Mapeamento de arquivos alterados/adicionados:
1. Geometric_Logo_Platform_class_diagram.mermaid
2. Geometric_Logo_Platform_sequence_diagram.mermaid
3. Geometric_Logo_Platform_system_design.md
4. src/components/EditorScreen/EditingCanvas.jsx
5. src/components/EditorScreen/PropertiesPanel.jsx
6. src/index.css
7. src/services/SVGManager.jsx
8. src/store/LogoStore.jsx

--- [1] Geometric_Logo_Platform_class_diagram.mermaid ---
classDiagram
    class App {
        <<component>>
        +render() ReactNode
    }

    class AppRouter {
        <<component>>
        +render() ReactNode
    }

    class EditorScreen {
        <<component>>
        -activeView: string
        +handleViewChange(view: string): void
        +render() ReactNode
    }

    class EditingCanvas {
        <<component>>
        -canvasRef: React.RefObject
        -svgManager: SVGManager
        -project: Project
        -selectedElementId: string | null
        +componentDidMount(): void
        +componentDidUpdate(): void
        +handleSvgClick(elementId: string): void
        +render() ReactNode
    }

    class PropertiesPanel {
        <<component>>
        -isOpen: boolean
        -selectedElementId: string | null
        -selectedElementType: string | null
        -elementProperties: ElementProperties | null
        +togglePanel(): void
        +applyChanges(changes: Partial~ElementProperties~): void
        +resetProperties(): void
        +render() ReactNode
    }

    class ShapeProperties {
        <<component>>
        -elementId: string
        -properties: Partial~ElementProperties~
        +handleColorChange(colorType: string, value: string): void
        +handleOpacityChange(value: number): void
        +handleTransformChange(type: string, value: any): void
        +resetProperty(property: string): void
        +render() ReactNode
    }

    class TextProperties {
        <<component>>
        -textElementId: string
        -textElement: TextElement
        +handleTextChange(value: string): void
        +handleFontChange(font: string): void
        +handleSizeChange(size: number): void
        +handleStyleChange(style: object): void
        +handleColorChange(value: string): void
        +handleAlignmentChange(alignment: string): void
        +resetProperty(property: string): void
        +render() ReactNode
    }

    class SVGManager {
        <<service>>
        -instance: SVGManager
        -svgElement: SVGElement | null
        -svgContainer: HTMLElement | null
        -elementSelectCallback: function | null
        -editableElements: Map~string, SVGElement~
        +getInstance(): SVGManager
        +initialize(svgContent: string, containerId: string): void
        +cleanup(): void
        +setElementSelectCallback(callback: function): void
        +getElementStyle(elementId: string): object
        +setElementStyle(elementId: string, styles: object): void
        +getElementTransform(elementId: string): object
        +setElementTransform(elementId: string, transform: object): void
        +highlightElement(elementId: string): void
        +clearHighlight(): void
        +addTextElement(textElement: TextElement): string
        +updateTextElement(id: string, props: object): void
        +removeTextElement(id: string): void
        +getSVGContent(): string
        +rasterize(format: string, scale: number): Promise~string~
        -_setupEventHandlers(): void
        -_cleanupEventHandlers(): void
        -_parseTransform(transformString: string): object
        -_applyTransform(element: SVGElement, transform: object): void
    }

    class LogoStore {
        <<store>>
        -state: LogoState
        +getState(): LogoState
        +setState(partialState: Partial~LogoState~): void
        +createNewProject(templateId: string): void
        +loadProject(projectId: string): void
        +saveProject(): void
        +selectElement(elementId: string): void
        +selectTextElement(textElementId: string): void
        +clearSelection(): void
        +updateElementStyle(elementId: string, styles: object): void
        +updateElementTransform(elementId: string, transform: object): void
        +updateTextElement(id: string, props: object): void
        +addTextElement(initialProps: object): string
        +removeTextElement(id: string): void
        +exportAsSVG(): string
        +exportAsPNG(): Promise~string~
        +exportAsJPG(): Promise~string~
    }

    class UIStore {
        <<store>>
        -state: UIState
        +getState(): UIState
        +setState(partialState: Partial~UIState~): void
        +setActiveScreen(screen: string): void
        +setActiveTab(tab: string): void
        +togglePropertiesPanel(): void
        +openTemplateModal(): void
        +closeTemplateModal(): void
    }

    class ColorPicker {
        <<component>>
        -color: string
        -onChange: function
        -label: string
        +handleChange(color: string): void
        +render() ReactNode
    }

    class TransformControls {
        <<component>>
        -transform: Transform
        -onChange: function
        +handleTranslateChange(axis: string, value: number): void
        +handleScaleChange(axis: string, value: number): void
        +handleRotateChange(value: number): void
        +resetTransform(): void
        +render() ReactNode
    }

    class TemplateSelector {
        <<component>>
        -templates: Template[]
        -selectedTemplateId: string | null
        -onSelect: function
        +handleTemplateSelect(templateId: string): void
        +render() ReactNode
    }

    class ExportPanel {
        <<component>>
        -format: string
        -exportInProgress: boolean
        +handleFormatChange(format: string): void
        +handleExport(): Promise~void~
        +render() ReactNode
    }

    App --> AppRouter
    AppRouter --> EditorScreen
    EditorScreen --> EditingCanvas
    EditorScreen --> PropertiesPanel
    PropertiesPanel --> ShapeProperties
    PropertiesPanel --> TextProperties
    ShapeProperties --> ColorPicker
    ShapeProperties --> TransformControls
    TextProperties --> ColorPicker
    EditingCanvas ..> SVGManager: uses
    EditingCanvas ..> LogoStore: uses
    PropertiesPanel ..> LogoStore: uses
    PropertiesPanel ..> UIStore: uses
    EditorScreen ..> UIStore: uses
    ShapeProperties ..> LogoStore: uses
    TextProperties ..> LogoStore: uses

--- [2] Geometric_Logo_Platform_sequence_diagram.mermaid ---
sequenceDiagram
    participant User
    participant EC as EditingCanvas
    participant SVG as SVGManager
    participant LS as LogoStore
    participant PP as PropertiesPanel
    participant SP as ShapeProperties
    participant TP as TextProperties

    %% Initialization Flow
    User->>EC: Open Editor Screen
    activate EC
    EC->>LS: Get current project
    activate LS
    LS-->>EC: Return project with SVG content
    deactivate LS
    EC->>SVG: initialize(svgContent, containerId)
    activate SVG
    SVG->>SVG: Parse SVG
    SVG->>SVG: _setupEventHandlers()
    SVG-->>EC: SVG initialized
    deactivate SVG
    EC->>SVG: setElementSelectCallback(selectElement)
    EC-->>User: Display editable SVG
    deactivate EC

    %% Element Selection Flow
    User->>EC: Click on SVG element
    activate EC
    EC->>SVG: Element click event
    activate SVG
    SVG->>SVG: Identify clicked element
    SVG->>LS: selectElement(elementId)
    activate LS
    LS->>SVG: getElementStyle(elementId)
    SVG-->>LS: Return element styles
    LS->>SVG: getElementTransform(elementId)
    SVG-->>LS: Return element transform
    LS->>LS: Update state (selectedElementId, currentElementStyles)
    LS-->>SVG: Element selected
    deactivate LS
    SVG->>SVG: highlightElement(elementId)
    SVG-->>EC: Selection processed
    deactivate SVG
    EC-->>User: Visual feedback (element highlighted)
    deactivate EC

    %% Properties Panel Update Flow
    LS->>PP: State changed (selectedElementId)
    activate PP
    PP->>LS: Get element properties
    LS-->>PP: Return current element properties
    PP->>PP: Determine element type (shape or text)
    alt Shape Element
        PP->>SP: Render with element properties
        activate SP
        SP-->>User: Display shape editing controls
        deactivate SP
    else Text Element
        PP->>TP: Render with text properties
        activate TP
        TP-->>User: Display text editing controls
        deactivate TP
    end
    PP-->>User: Show properties panel for selected element
    deactivate PP

    %% Property Editing Flow (Shape)
    User->>SP: Change color or transform
    activate SP
    SP->>LS: updateElementStyle(elementId, newStyles)
    activate LS
    LS->>SVG: setElementStyle(elementId, newStyles)
    activate SVG
    SVG->>SVG: Apply style to DOM element
    SVG-->>LS: Style applied
    deactivate SVG
    LS->>LS: Update state
    LS-->>SP: Change confirmed
    deactivate LS
    SP-->>User: Show updated control state
    deactivate SP

    %% Property Editing Flow (Text)
    User->>TP: Edit text properties
    activate TP
    TP->>LS: updateTextElement(textElementId, newProps)
    activate LS
    LS->>SVG: updateTextElement(textElementId, newProps)
    activate SVG
    SVG->>SVG: Update text DOM element
    SVG-->>LS: Text updated
    deactivate SVG
    LS->>LS: Update text elements in state
    LS-->>TP: Change confirmed
    deactivate LS
    TP-->>User: Show updated text
    deactivate TP

    %% Reset Properties Flow
    User->>PP: Click reset button
    activate PP
    PP->>LS: Get original element properties
    LS-->>PP: Return original properties
    PP->>LS: updateElementStyle(elementId, originalStyles)
    activate LS
    LS->>SVG: setElementStyle(elementId, originalStyles)
    SVG-->>LS: Original style applied
    LS-->>PP: Reset complete
    deactivate LS
    PP-->>User: Show original property values
    deactivate PP

    %% Export Flow
    User->>LS: exportAsSVG()
    activate LS
    LS->>SVG: getSVGContent()
    SVG-->>LS: Return final SVG content
    LS-->>User: Provide SVG for download
    deactivate LS

--- [3] Geometric_Logo_Platform_system_design.md ---
# Geometric Logo Platform - System Design Document

## 1. Implementation Approach

### 1.1 Overview
The Geometric Logo Platform is a web-based application that allows users to select SVG templates, customize elements (colors, transformations), add text, and export the final logo. The application is entirely client-side ('self-contained') built with React, Zustand for state management, and Tailwind CSS for styling.

### 1.2 Technology Stack
- **Frontend Framework**: React.js
- **State Management**: Zustand
- **Styling**: Tailwind CSS
- **SVG Manipulation**: Custom SVGManager service
- **Bundling**: Vite

### 1.3 Key Challenges and Solutions

#### 1.3.1 SVG Element Selection and Editing
The platform needs to allow users to interact with SVG elements for editing. This involves:
- Identifying clickable elements with proper class markers (`editable`, `primary-color-element`, `secondary-color-element`, etc.)
- Providing visual feedback when hovering/selecting elements
- Recording selected elements in the application state
- Displaying appropriate editing controls based on the selected element type

#### 1.3.2 Properties Panel Implementation
The properties panel must dynamically update based on the selected element, showing:
- For shape elements: color pickers, transformation controls, opacity slider
- For text elements: font family selector, font size, alignment, color picker, bold/italic toggles

#### 1.3.3 Real-time Preview
All edits must be immediately reflected in the editor canvas, requiring a robust two-way binding between:
- The properties panel controls
- The application state (via Zustand)
- The actual SVG DOM manipulation (via SVGManager)

## 2. Data Structures and Interfaces

### 2.1 Core Data Models

#### Project
Represents a complete logo project with all its elements and configurations.

```typescript
interface Project {
  id: string;
  name: string;
  svgContent: string;  // Current SVG content as string
  templateId: string;  // ID of the base template
  elements: {[elementId: string]: ElementProperties};
  textElements: TextElement[];
  createdAt: Date;
  updatedAt: Date;
}
```

#### ElementProperties
Stores properties for each SVG element in the logo.

```typescript
interface ElementProperties {
  id: string;
  type: 'path' | 'circle' | 'rect' | 'ellipse' | 'polygon' | 'polyline' | 'g';
  fill: string | null;
  stroke: string | null;
  strokeWidth: number | null;
  opacity: number;
  transform: {
    translate: {x: number, y: number},
    scale: {x: number, y: number},
    rotate: number,
  };
  originalAttributes: Object;  // Original SVG attributes
}
```

#### TextElement
Represents text elements added to the logo.

```typescript
interface TextElement {
  id: string;
  content: string;
  fontFamily: string;
  fontSize: number;
  fontWeight: string;
  fontStyle: string;
  textAlignment: 'start' | 'middle' | 'end';
  fill: string;
  position: {x: number, y: number};
  transform: {
    translate: {x: number, y: number},
    scale: {x: number, y: number},
    rotate: number,
  };
}
```

### 2.2 State Management

The application uses Zustand for state management with the following main stores:

#### LogoStore
Central store managing the logo editing state.

```typescript
interface LogoState {
  // Project data
  currentProject: Project | null;
  availableTemplates: Template[];
  isLoading: boolean;
  error: string | null;
  
  // Selection state
  selectedElementId: string | null;
  selectedTextElementId: string | null;
  currentElementStyles: Partial<ElementProperties> | null;
  
  // Actions
  createNewProject: (templateId: string) => void;
  loadProject: (projectId: string) => void;
  saveProject: () => void;
  
  // Element selection
  selectElement: (elementId: string) => void;
  selectTextElement: (textElementId: string) => void;
  clearSelection: () => void;
  
  // Element modification
  updateElementStyle: (elementId: string, styles: Partial<ElementProperties>) => void;
  updateElementTransform: (elementId: string, transform: Partial<Transform>) => void;
  updateTextElement: (textElementId: string, props: Partial<TextElement>) => void;
  
  // Text operations
  addTextElement: (initialProps?: Partial<TextElement>) => void;
  removeTextElement: (textElementId: string) => void;
  
  // Export operations
  exportAsSVG: () => string;
  exportAsPNG: () => Promise<string>;
  exportAsJPG: () => Promise<string>;
}
```

#### UIStore
Manages UI-related state like active screens, modals, etc.

```typescript
interface UIState {
  activeScreen: 'welcome' | 'templates' | 'editor' | 'typography' | 'export';
  isPropertiesPanelOpen: boolean;
  activeTab: 'shape' | 'text' | 'export';
  isTemplateModalOpen: boolean;
  isSaveModalOpen: boolean;
  
  // Actions
  setActiveScreen: (screen: UIState['activeScreen']) => void;
  setActiveTab: (tab: UIState['activeTab']) => void;
  togglePropertiesPanel: () => void;
  openTemplateModal: () => void;
  closeTemplateModal: () => void;
  openSaveModal: () => void;
  closeSaveModal: () => void;
}
```

## 3. Key Components and Services

### 3.1 Core Services

#### SVGManager
Handles all DOM manipulation of SVG elements.

```typescript
class SVGManager {
  // Initialization
  initialize(svgContent: string, containerId: string): void;
  cleanup(): void;
  
  // Selection management
  setElementSelectCallback(callback: (elementId: string) => void): void;
  highlightElement(elementId: string): void;
  clearHighlight(): void;
  
  // Element properties
  getElementStyle(elementId: string): Partial<ElementProperties>;
  setElementStyle(elementId: string, styles: Partial<ElementProperties>): void;
  getElementTransform(elementId: string): Transform;
  setElementTransform(elementId: string, transform: Partial<Transform>): void;
  
  // Text management
  addTextElement(textElement: TextElement): void;
  updateTextElement(textElementId: string, props: Partial<TextElement>): void;
  removeTextElement(textElementId: string): void;
  
  // Export
  getSVGContent(): string;
  rasterize(format: 'png' | 'jpg', scale?: number): Promise<string>;
}
```

### 3.2 Main Components

#### App Structure
- **AppRouter**: Manages navigation between main screens
- **MainLayout**: Common layout wrapping all screens

#### Editor Screen Components
- **EditorScreen**: Main container for the editor
- **EditingCanvas**: SVG display and interaction area
- **PropertiesPanel**: Dynamic panel displaying controls for selected elements
  - **ShapeProperties**: Controls specific to shapes (color, opacity, etc)
  - **TextProperties**: Controls specific to text elements
- **ToolsSidebar**: Tools and operations (undo/redo, alignment, etc)

#### PropertiesPanel Components
- **ColorPicker**: Custom color selection control
- **TransformationControls**: Interface for scale, rotation, translation
- **OpacitySlider**: Slider for adjusting element opacity
- **ResetButton**: Button to reset element to original properties
- **TextFormatControls**: Text-specific formatting tools

## 4. Key Implementation Requirements

### 4.1 SVG Element Selection and Editing
1. All SVG templates must have `.editable` class on elements that should be selectable
2. Color-editable elements should have additional classes: `.primary-color-element`, `.secondary-color-element`, etc.
3. The SVGManager must attach click handlers to all elements with the `.editable` class
4. When an element is selected:
   - Its ID must be stored in LogoStore.selectedElementId
   - Its current styles must be extracted and stored in LogoStore.currentElementStyles
   - The PropertiesPanel must update to show the relevant controls
   - Visual indication should appear (highlight, handles, etc.)

### 4.2 Properties Panel Implementation
1. The panel must dynamically render different controls based on selected element type
2. Controls must be two-way bound to the store state
3. Changes must be immediately applied to the SVG
4. Each property section should include a reset button to restore defaults

### 4.3 Text Element Handling
1. Text elements are represented differently from SVG elements
2. Adding text creates a new SVG text element in the DOM
3. Text-specific properties (font, alignment, etc.) require dedicated controls

## 5. Anything UNCLEAR

1. **User Permissions**: The current design doesn't address user authentication or project storage persistence. It's assumed projects are stored locally.

2. **Template Management**: The system for adding/importing new templates needs further specification.

3. **Advanced Features**: Features like layers management, grouping/ungrouping elements, and keyboard shortcuts need further implementation details.

4. **Performance Optimization**: For complex SVGs with many elements, optimization strategies may be needed for smooth editing experience.

--- [4] src/components/EditorScreen/EditingCanvas.jsx ---
import React, { useEffect, useRef } from 'react';
import useLogoStore from '../../store/LogoStore';
import svgManager from '../../services/SVGManager';

const EditingCanvas = () => {
  const canvasRef = useRef(null);
  const selectElement = useLogoStore(state => state.selectElement);
  const selectedElementId = useLogoStore(state => state.currentProject.selectedElementId);
  const selectedLogoId = useLogoStore(state => state.currentProject.selectedLogoId);
  
  // Get the current SVG content from the store
  const svgContent = useLogoStore(state => state.currentProject.svgContent);
  
  // Set up SVG manager and initialize the canvas
  useEffect(() => {
    if (!canvasRef.current || !selectedLogoId || !svgContent) return;
    
    console.log('Initializing SVG in EditingCanvas with content:', svgContent.substring(0, 50) + '...');
    
    // Set the element select callback on the SVG manager
    svgManager.setElementSelectCallback((elementId) => {
      console.log('SVG element selected:', elementId);
      selectElement(elementId);
    });
    
    // Initialize the SVG content in the canvas
    const success = svgManager.initialize(svgContent, "editing-canvas");
    
    if (!success) {
      console.error('Failed to initialize SVG manager');
      return;
    }
    
    // Add CSS for selection highlighting if not already present
    const styleId = 'svg-editor-styles';
    if (!document.getElementById(styleId)) {
      const style = document.createElement('style');
      style.id = styleId;
      style.textContent = `
        #editing-canvas svg * {
          transition: all 0.1s ease;
        }
        #editing-canvas .selected-highlight {
          outline: 3px dashed #2563eb !important;
          outline-offset: 2px !important;
        }
        #editing-canvas .hover-highlight {
          stroke: #2563eb80 !important;
          stroke-width: 1px !important;
          opacity: 0.9 !important;
          cursor: pointer !important;
        }
      `;
      document.head.appendChild(style);
    }
    
  }, [canvasRef, selectElement, selectedLogoId, svgContent]);
  
  return (
    <div className="h-full flex flex-col">
      <h2 className="text-xl font-semibold mb-4">Logo Canvas</h2>
      <p className="text-sm text-gray-600 mb-4">
        Click on any element of the logo to select and edit it. Use the properties panel to adjust colors, size, and position.
      </p>
      
      <div className="flex-1 flex items-center justify-center bg-white rounded-lg shadow-inner border border-gray-200">
        <div 
          id="editing-canvas" 
          ref={canvasRef} 
          className="w-full max-w-md mx-auto h-full max-h-96 flex items-center justify-center"
        >
          {/* SVG will be rendered here by SVGManager */}
        </div>
      </div>
      
      <div className="mt-4 text-sm text-gray-500 italic">
        {selectedElementId ? (
          <div>Selected element: <span className="font-medium">{selectedElementId}</span></div>
        ) : (
          <div>Click on a logo element to select and edit it</div>
        )}
      </div>
    </div>
  );
};

export default EditingCanvas;

--- [5] src/components/EditorScreen/PropertiesPanel.jsx ---
import React from 'react';
import useLogoStore from '../../store/LogoStore';
import svgManager from '../../services/SVGManager';

const PropertiesPanel = () => {
  const { currentProject, updateElement, updateElementTransform } = useLogoStore(state => ({
    currentProject: state.currentProject,
    updateElement: state.updateElement,
    updateElementTransform: state.updateElementTransform
  }));
  
  const { elements, selectedElementId, currentElementStyles, transformations } = currentProject;
  const selectedElementFromMap = selectedElementId ? elements.get(selectedElementId) : null;
  const selectedElementTransform = selectedElementId ? transformations.get(selectedElementId) : null;
  
  // Combine element data from both sources
  const selectedElement = selectedElementId ? {
    ...selectedElementFromMap,
    ...currentElementStyles,
  } : null;
  
  // Handle style changes
  const handleStyleChange = (property, value) => {
    if (!selectedElementId) return;
    
    updateElement(selectedElementId, { [property]: value });
  };
  
  // Handle transformation changes
  const handleTransformChange = (property, value) => {
    if (!selectedElementId) return;
    
    const currentTransform = selectedElementTransform || {
      translateX: 0, translateY: 0, rotation: 0, scaleX: 1, scaleY: 1
    };
    
    // Update the appropriate transform property
    const transformUpdate = {};
    if (property === 'translateX') {
      transformUpdate.translateX = Number(value);
    } else if (property === 'translateY') {
      transformUpdate.translateY = Number(value);
    } else if (property === 'rotation') {
      transformUpdate.rotation = Number(value);
    } else if (property === 'scaleX') {
      transformUpdate.scaleX = Number(value);
    } else if (property === 'scaleY') {
      transformUpdate.scaleY = Number(value);
    }
    
    updateElementTransform(selectedElementId, transformUpdate);
  };
  
  if (!selectedElement) {
    return (
      <div className="h-full flex items-center justify-center">
        <p className="text-gray-500 text-center p-4">
          Select an element from the logo to edit its properties
        </p>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-semibold mb-4">Element Properties</h3>
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Element Type</label>
            <div className="bg-gray-100 p-2 rounded text-sm">{selectedElement.type}</div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Element ID</label>
            <div className="bg-gray-100 p-2 rounded text-sm">{selectedElement.id}</div>
          </div>
        </div>
      </div>
      
      <div className="border-t pt-4">
        <h4 className="font-medium mb-3">Style</h4>
        
        {selectedElement.fill !== 'none' && (
          <div className="mb-3">
            <label className="block text-sm font-medium text-gray-700 mb-1">Fill Color</label>
            <div className="flex items-center">
              <input 
                type="color" 
                value={selectedElement.fill || '#000000'} 
                onChange={(e) => handleStyleChange('fill', e.target.value)}
                className="h-10 w-14 border-0"
              />
              <input 
                type="text" 
                value={selectedElement.fill || '#000000'} 
                onChange={(e) => handleStyleChange('fill', e.target.value)}
                className="ml-2 flex-1 border rounded p-1 text-sm"
              />
            </div>
          </div>
        )}
        
        {selectedElement.stroke !== 'none' && (
          <>
            <div className="mb-3">
              <label className="block text-sm font-medium text-gray-700 mb-1">Stroke Color</label>
              <div className="flex items-center">
                <input 
                  type="color" 
                  value={selectedElement.stroke || '#000000'} 
                  onChange={(e) => handleStyleChange('stroke', e.target.value)}
                  className="h-10 w-14 border-0"
                />
                <input 
                  type="text" 
                  value={selectedElement.stroke || '#000000'} 
                  onChange={(e) => handleStyleChange('stroke', e.target.value)}
                  className="ml-2 flex-1 border rounded p-1 text-sm"
                />
              </div>
            </div>
            
            <div className="mb-3">
              <label className="block text-sm font-medium text-gray-700 mb-1">Stroke Width</label>
              <input 
                type="range" 
                min="0" 
                max="20" 
                step="0.5"
                value={selectedElement.strokeWidth || 0} 
                onChange={(e) => handleStyleChange('strokeWidth', Number(e.target.value))}
                className="w-full"
              />
              <div className="text-xs text-gray-500 mt-1">{selectedElement.strokeWidth || 0}px</div>
            </div>
          </>
        )}
        
        <div className="mb-3">
          <label className="block text-sm font-medium text-gray-700 mb-1">Opacity</label>
          <input 
            type="range" 
            min="0" 
            max="1" 
            step="0.01"
            value={selectedElement.opacity || 1} 
            onChange={(e) => handleStyleChange('opacity', Number(e.target.value))}
            className="w-full"
          />
          <div className="text-xs text-gray-500 mt-1">{Math.round((selectedElement.opacity || 1) * 100)}%</div>
        </div>
      </div>
      
      <div className="border-t pt-4">
        <h4 className="font-medium mb-3">Transformation</h4>
        
        <div className="grid grid-cols-2 gap-3 mb-3">
          <div>
            <label className="block text-xs font-medium text-gray-700 mb-1">X Position</label>
            <input 
              type="number"
              value={selectedElementTransform?.translateX || 0} 
              onChange={(e) => handleTransformChange('translateX', e.target.value)}
              className="w-full border rounded p-1 text-sm"
            />
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 mb-1">Y Position</label>
            <input 
              type="number"
              value={selectedElementTransform?.translateY || 0} 
              onChange={(e) => handleTransformChange('translateY', e.target.value)}
              className="w-full border rounded p-1 text-sm"
            />
          </div>
        </div>
        
        <div className="mb-3">
          <label className="block text-sm font-medium text-gray-700 mb-1">Rotation (degrees)</label>
          <input 
            type="range" 
            min="0" 
            max="360" 
            step="1"
            value={selectedElementTransform?.rotation || 0} 
            onChange={(e) => handleTransformChange('rotation', e.target.value)}
            className="w-full"
          />
          <div className="text-xs text-gray-500 mt-1">{selectedElementTransform?.rotation || 0}°</div>
        </div>
        
        <div className="grid grid-cols-2 gap-3">
          <div>
            <label className="block text-xs font-medium text-gray-700 mb-1">Scale X</label>
            <input 
              type="range" 
              min="0.1" 
              max="2" 
              step="0.05"
              value={selectedElementTransform?.scaleX || 1} 
              onChange={(e) => handleTransformChange('scaleX', e.target.value)}
              className="w-full"
            />
            <div className="text-xs text-gray-500 mt-1">{selectedElementTransform?.scaleX || 1}x</div>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 mb-1">Scale Y</label>
            <input 
              type="range" 
              min="0.1" 
              max="2" 
              step="0.05"
              value={selectedElementTransform?.scaleY || 1} 
              onChange={(e) => handleTransformChange('scaleY', e.target.value)}
              className="w-full"
            />
            <div className="text-xs text-gray-500 mt-1">{selectedElementTransform?.scaleY || 1}x</div>
          </div>
        </div>
      </div>
      
      <div className="border-t pt-4">
        <button 
          className="px-4 py-2 bg-red-50 text-red-600 hover:bg-red-100 rounded w-full"
          onClick={() => {
            // Reset styles
            updateElement(selectedElementId, {
              fill: selectedElement.original?.fill || selectedElement.fill,
              stroke: selectedElement.original?.stroke || selectedElement.stroke,
              strokeWidth: selectedElement.original?.strokeWidth || selectedElement.strokeWidth,
              opacity: 1
            });
            
            // Reset transformations
            updateElementTransform(selectedElementId, {
              translateX: 0,
              translateY: 0,
              rotation: 0,
              scaleX: 1,
              scaleY: 1
            });
          }}
        >
          Reset to Default
        </button>
      </div>
    </div>
  );
};

export default PropertiesPanel;

--- [6] src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

::-webkit-scrollbar {
  width: 5px;
  height: 5px;
}

::-webkit-scrollbar-track {
  background-color: transparent;
}

::-webkit-scrollbar-thumb {
  border-radius: 25px;
  transition: all 0.3s;
  background-color: rgba(106, 115, 125, 0.2);
  &:hover {
    background-color: rgba(106, 115, 125, 0.27);
  }
}

::-webkit-scrollbar-corner {
  display: none;
}

/* SVG Element Selection Styles */
.selected-highlight {
  outline: 2px dashed #2563eb; /* Blue outline */
  outline-offset: 2px;
}

.hover-highlight {
  stroke: #2563eb80;
  stroke-width: 1;
  opacity: 0.9;
  cursor: pointer;
}


--- [7] src/services/SVGManager.jsx ---
/**
 * SVGManager.jsx - Serviço para gerenciar e manipular elementos SVG
 */
class SVGManager {
  constructor() {
    this.svgContainer = null;
    this.svgElement = null;
    this.svgNamespace = "http://www.w3.org/2000/svg";
    this.elementSelectCallback = null;
    this.selectedElement = null;
    this._eventListeners = new Map(); // Track event listeners for cleanup
  }

  _cleanup() {
    // Remove all event listeners
    if (this._eventListeners.size > 0) {
      this._eventListeners.forEach((listeners, element) => {
        listeners.forEach(({type, handler}) => {
          element.removeEventListener(type, handler);
        });
      });
      this._eventListeners.clear();
    }

    // Clear the container
    if (this.svgContainer) {
      while (this.svgContainer.firstChild) {
        this.svgContainer.removeChild(this.svgContainer.firstChild);
      }
    }

    // Reset selected element
    if (this.selectedElement) {
      this.selectedElement.classList.remove('selected-highlight');
      this.selectedElement = null;
    }
  }

  // Inicializar o SVG Manager com conteúdo SVG em um container específico
  initialize(svgContent, containerId) {
    this.svgContainer = document.getElementById(containerId);
    
    if (!this.svgContainer) {
      console.error('Container não encontrado:', containerId);
      return false;
    }
    
    if (!svgContent || typeof svgContent !== 'string') {
      console.error('SVG content inválido');
      return false;
    }
    
    // Limpar o container e remover event listeners antigos
    this._cleanup();
    
    // Criar parser de DOM para o SVG
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
    
    // Verificar se o parsing foi bem sucedido
    const parserError = svgDoc.querySelector('parsererror');
    if (parserError) {
      console.error('SVG parsing error:', parserError.textContent);
      return false;
    }
    
    this.svgElement = svgDoc.documentElement;
    
    // Validar se é realmente um elemento SVG
    if (this.svgElement.tagName !== 'svg') {
      console.error('O documento não é um SVG válido');
      return false;
    }
    
    // Garantir que o SVG tenha viewBox e dimensões adequadas
    if (!this.svgElement.getAttribute('viewBox')) {
      this.svgElement.setAttribute('viewBox', '0 0 400 400');
    }
    if (!this.svgElement.getAttribute('width')) {
      this.svgElement.setAttribute('width', '100%');
    }
    if (!this.svgElement.getAttribute('height')) {
      this.svgElement.setAttribute('height', '100%');
    }
    
    // Adicionar o SVG ao container
    this.svgContainer.appendChild(this.svgElement);
    
    // Configurar eventos para os elementos SVG
    this._setupEventHandlers();
    
    return true;
  }

  // Configurar os handlers de eventos para os elementos SVG
  _setupEventHandlers() {
    console.log('Setting up SVG event handlers');
    
    // Selecionar todos os elementos que podem ser manipulados
    const editableElements = this.svgElement.querySelectorAll('path, circle, rect, ellipse, polygon, polyline, g, text');
    
    console.log(`Found ${editableElements.length} editable elements`); 
    
    editableElements.forEach((element, index) => {
      // Garantir que cada elemento tenha um ID único
      if (!element.id) {
        element.id = `element-${Date.now()}-${index}`;
      }
      
      // Adicionar evento de clique para seleção
      const clickHandler = (event) => {
        event.stopPropagation();
        console.log(`Element clicked: ${element.id}`);
        
        // Destacar visualmente o elemento
        this.highlightSelectedElement(element.id);
        
        // Chamar o callback se existir
        if (this.elementSelectCallback) {
          this.elementSelectCallback(element.id);
        }
      };
      
      // Registrar o handler para limpeza posterior
      if (!this._eventListeners.has(element)) {
        this._eventListeners.set(element, []);
      }
      this._eventListeners.get(element).push({ type: 'click', handler: clickHandler });
      
      element.addEventListener('click', clickHandler);
      
      // Adicionar estilo hover para indicar elementos clicáveis
      element.style.cursor = 'pointer';
      
      // Adicionar eventos de hover para feedback visual
      const mouseEnterHandler = () => {
        if (this.selectedElement !== element) {
          element.classList.add('hover-highlight');
        }
      };
      
      const mouseLeaveHandler = () => {
        element.classList.remove('hover-highlight');
      };
      
      element.addEventListener('mouseenter', mouseEnterHandler);
      element.addEventListener('mouseleave', mouseLeaveHandler);
      
      this._eventListeners.get(element).push(
        { type: 'mouseenter', handler: mouseEnterHandler },
        { type: 'mouseleave', handler: mouseLeaveHandler }
      );
    });
    
    // Clicar no SVG (fora dos elementos) deve desselecionar
    const svgClickHandler = (event) => {
      if (event.target === this.svgElement) {
        console.log('Background clicked, clearing selection');
        
        // Limpar o destaque visual
        this.highlightSelectedElement(null);
        
        if (this.elementSelectCallback) {
          this.elementSelectCallback(null); // Desselecionar
        }
      }
    };
    
    // Registrar o handler do SVG para limpeza
    if (!this._eventListeners.has(this.svgElement)) {
      this._eventListeners.set(this.svgElement, []);
    }
    this._eventListeners.get(this.svgElement).push({ type: 'click', handler: svgClickHandler });
    
    this.svgElement.addEventListener('click', svgClickHandler);
  }

  // Definir callback para quando um elemento for selecionado
  setElementSelectCallback(callback) {
    this.elementSelectCallback = callback;
  }

  // Analisar o SVG e criar um mapa de elementos com suas propriedades
  async parseSVGElements(svgContent) {
    if (!svgContent || typeof svgContent !== 'string') {
      console.error('SVG content inválido para parsing');
      return new Map();
    }

    try {
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
      
      // Verificar erros de parsing
      const parserError = svgDoc.querySelector('parsererror');
      if (parserError) {
        throw new Error(`SVG parsing error: ${parserError.textContent}`);
      }
      
      const svgElement = svgDoc.documentElement;
      if (svgElement.tagName !== 'svg') {
        throw new Error('O documento não é um SVG válido');
      }
      
      // Encontrar todos os elementos que podem ser editados
      const editableElements = svgElement.querySelectorAll('path, circle, rect, ellipse, polygon, polyline, g');
      const elementMap = new Map();
      const usedIds = new Set(); // Rastrear IDs já utilizados
      
      editableElements.forEach((element, index) => {
        let elementId = element.id || element.getAttribute('data-id');
        
        // Se não tem ID ou o ID já está em uso, gerar um novo
        if (!elementId || usedIds.has(elementId)) {
          elementId = `element-${Date.now()}-${index}`;
          element.id = elementId;
        }
        
        usedIds.add(elementId);
        
        // Extrair propriedades relevantes com valores padrão seguros
        const properties = {
          type: element.tagName,
          fill: element.getAttribute('fill') || '#000000',
          stroke: element.getAttribute('stroke') || 'none',
          strokeWidth: parseFloat(element.getAttribute('stroke-width')) || 0,
          opacity: parseFloat(element.getAttribute('opacity')) || 1,
          role: element.getAttribute('data-role') || null,
          // Adicionado timestamp para garantir unicidade em recargas
          timestamp: Date.now(),
          originalId: element.id // Manter registro do ID original se necessário
        };
        
        elementMap.set(elementId, properties);
      });
      
      return elementMap;
    } catch (error) {
      console.error('Erro ao analisar elementos SVG:', error);
      return new Map(); // Retornar Map vazio em caso de erro
    }
  }

  // Atualizar propriedade de um elemento
  updateElementProperty(elementId, property, value) {
    if (!this.svgElement) return false;
    
    const element = this.svgElement.getElementById(elementId);
    if (!element) {
      console.error('Elemento não encontrado:', elementId);
      return false;
    }
    
    // Mapear propriedades para atributos SVG
    const attrMap = {
      fill: 'fill',
      stroke: 'stroke',
      strokeWidth: 'stroke-width',
      opacity: 'opacity',
      // Outras propriedades podem ser mapeadas aqui
    };
    
    const attr = attrMap[property];
    if (attr) {
      element.setAttribute(attr, value);
      return true;
    }
    
    return false;
  }

  // Adicionar elemento de texto ao SVG
  addTextElement(textProps) {
    if (!this.svgElement) return false;
    
    const {
      id,
      content,
      fontFamily = 'Arial',
      fontSize = 24,
      fontWeight = '400',
      fill = '#000000',
      position = { x: 200, y: 200 },
      alignment = 'middle'
    } = textProps;
    
    // Criar elemento de texto SVG
    const textElement = document.createElementNS(this.svgNamespace, 'text');
    textElement.setAttribute('id', id);
    textElement.setAttribute('x', position.x);
    textElement.setAttribute('y', position.y);
    textElement.setAttribute('font-family', fontFamily);
    textElement.setAttribute('font-size', fontSize);
    textElement.setAttribute('font-weight', fontWeight);
    textElement.setAttribute('fill', fill);
    textElement.setAttribute('text-anchor', alignment === 'center' ? 'middle' : alignment);
    textElement.setAttribute('dominant-baseline', 'middle');
    textElement.textContent = content;
    
    // Adicionar estilo hover para indicar elementos clicáveis
    textElement.style.cursor = 'pointer';
    
    // Adicionar evento de clique para seleção
    textElement.addEventListener('click', (event) => {
      event.stopPropagation();
      if (this.elementSelectCallback) {
        this.elementSelectCallback(id);
      }
    });
    
    // Adicionar ao SVG
    this.svgElement.appendChild(textElement);
    
    return true;
  }

  // Atualizar elemento de texto
  updateTextElement(textId, properties) {
    if (!this.svgElement) return false;
    
    const textElement = this.svgElement.getElementById(textId);
    if (!textElement) {
      console.error('Elemento de texto não encontrado:', textId);
      return false;
    }
    
    // Mapear propriedades para atributos SVG
    if (properties.content !== undefined) {
      textElement.textContent = properties.content;
    }
    if (properties.fontFamily !== undefined) {
      textElement.setAttribute('font-family', properties.fontFamily);
    }
    if (properties.fontSize !== undefined) {
      textElement.setAttribute('font-size', properties.fontSize);
    }
    if (properties.fontWeight !== undefined) {
      textElement.setAttribute('font-weight', properties.fontWeight);
    }
    if (properties.fill !== undefined) {
      textElement.setAttribute('fill', properties.fill);
    }
    if (properties.position !== undefined) {
      textElement.setAttribute('x', properties.position.x);
      textElement.setAttribute('y', properties.position.y);
    }
    if (properties.alignment !== undefined) {
      textElement.setAttribute('text-anchor', properties.alignment === 'center' ? 'middle' : properties.alignment);
    }
    
    return true;
  }
  
  // Remover elemento de texto
  removeTextElement(textId) {
    if (!this.svgElement) return false;
    
    const textElement = this.svgElement.getElementById(textId);
    if (!textElement) {
      console.error('Elemento de texto não encontrado para remoção:', textId);
      return false;
    }
    
    // Remover o elemento do DOM
    textElement.parentNode.removeChild(textElement);
    
    // Se este era o elemento selecionado, limpar a seleção
    if (this.selectedElement && this.selectedElement.id === textId) {
      this.selectedElement = null;
    }
    
    return true;
  }
  
  // Obter o conteúdo SVG atual como string
  getSVGContent() {
    if (!this.svgElement) return null;
    
    // Clonar para não modificar o original
    const clone = this.svgElement.cloneNode(true);
    
    // Limpar classes de seleção
    const selectedElements = clone.querySelectorAll('.selected-element');
    selectedElements.forEach(el => {
      el.classList.remove('selected-element');
    });
    
    return new XMLSerializer().serializeToString(clone);
  }
  
  // Aplicar estilo a um elemento SVG
  applyStyle(elementId, styles) {
    if (!this.svgElement) return false;
    
    const element = this.svgElement.getElementById(elementId);
    if (!element) {
      console.error('Elemento não encontrado:', elementId);
      return false;
    }
    
    // Aplicar os estilos ao elemento
    if (styles.fill !== undefined) {
      element.setAttribute('fill', styles.fill);
    }
    
    if (styles.stroke !== undefined) {
      element.setAttribute('stroke', styles.stroke);
    }
    
    if (styles.strokeWidth !== undefined) {
      element.setAttribute('stroke-width', styles.strokeWidth);
    }
    
    if (styles.opacity !== undefined) {
      element.setAttribute('opacity', styles.opacity);
    }
    
    return true;
  }
  
  // Aplicar transformações a um elemento SVG
  applyTransformation(elementId, transformData) {
    if (!this.svgElement) return false;
    
    const element = this.svgElement.getElementById(elementId);
    if (!element) {
      console.error('Elemento não encontrado:', elementId);
      return false;
    }
    
    // Extrair valores de transformação ou usar valores padrão
    const {
      x = 0,
      y = 0,
      rotation = 0,
      scaleX = 1,
      scaleY = 1
    } = transformData;
    
    // Determinar o centro do elemento para rotação
    let centerX = 0;
    let centerY = 0;
    
    // Para formas diferentes, determinar o centro de rotação
    if (element.tagName === 'rect') {
      // Para retângulos, usar o centro do retângulo
      const width = parseFloat(element.getAttribute('width') || 0);
      const height = parseFloat(element.getAttribute('height') || 0);
      centerX = width / 2;
      centerY = height / 2;
    } else if (element.tagName === 'circle') {
      // Para círculos, usar o centro definido pelos atributos cx e cy
      centerX = parseFloat(element.getAttribute('cx') || 0);
      centerY = parseFloat(element.getAttribute('cy') || 0);
    } else if (element.tagName === 'ellipse') {
      // Para elipses, usar o centro definido pelos atributos cx e cy
      centerX = parseFloat(element.getAttribute('cx') || 0);
      centerY = parseFloat(element.getAttribute('cy') || 0);
    } else if (element.tagName === 'path' || element.tagName === 'g') {
      // Para paths e grupos, calcular o centro pelo BBox
      try {
        const bbox = element.getBBox();
        centerX = bbox.x + bbox.width / 2;
        centerY = bbox.y + bbox.height / 2;
      } catch (e) {
        console.warn('Não foi possível calcular o BBox para', element.tagName);
        // Fallback para o centro do SVG
        centerX = 200;
        centerY = 200;
      }
    } else {
      // Fallback para elementos não suportados
      centerX = 200;
      centerY = 200;
    }
    
    // Construir a string de transformação SVG
    const transformString = `translate(${x}, ${y}) rotate(${rotation}, ${centerX}, ${centerY}) scale(${scaleX}, ${scaleY})`;
    
    // Aplicar a transformação ao elemento
    element.setAttribute('transform', transformString);
    
    return true;
  }
  
  // Obter estilo de um elemento SVG
  getElementStyle(elementId) {
    if (!this.svgElement) return null;
    
    const element = this.svgElement.getElementById(elementId);
    if (!element) {
      console.error('Elemento não encontrado:', elementId);
      return null;
    }
    
    // Retornar objeto com todas as propriedades de estilo relevantes
    return {
      fill: element.getAttribute('fill') || '#000000',
      stroke: element.getAttribute('stroke') || 'none',
      strokeWidth: element.getAttribute('stroke-width') ? parseFloat(element.getAttribute('stroke-width')) : 0,
      opacity: element.getAttribute('opacity') ? parseFloat(element.getAttribute('opacity')) : 1
    };
  }
  
  // Obter transformação de um elemento SVG
  getElementTransform(elementId) {
    if (!this.svgElement) return null;
    
    const element = this.svgElement.getElementById(elementId);
    if (!element) {
      console.error('Elemento não encontrado:', elementId);
      return null;
    }
    
    // Obter o atributo de transformação
    const transformAttr = element.getAttribute('transform') || '';
    
    // Valores padrão se não houver transformação
    const transformData = {
      translateX: 0,
      translateY: 0,
      scaleX: 1,
      scaleY: 1,
      rotation: 0
    };
    
    // Extrair valores de translate
    const translateMatch = transformAttr.match(/translate\(\s*([\d.-]+)\s*[,\s]\s*([\d.-]+)\s*\)/);
    if (translateMatch) {
      transformData.translateX = parseFloat(translateMatch[1]);
      transformData.translateY = parseFloat(translateMatch[2]);
    }
    
    // Extrair valores de scale
    const scaleMatch = transformAttr.match(/scale\(\s*([\d.-]+)\s*[,\s]\s*([\d.-]+)\s*\)/);
    if (scaleMatch) {
      transformData.scaleX = parseFloat(scaleMatch[1]);
      transformData.scaleY = parseFloat(scaleMatch[2]);
    }
    
    // Extrair valor de rotação - pegando apenas o valor de ângulo, ignorando o centro
    const rotateMatch = transformAttr.match(/rotate\(\s*([\d.-]+)/);
    if (rotateMatch) {
      transformData.rotation = parseFloat(rotateMatch[1]);
    }
    
    return transformData;
  }
  
  // Destacar elemento selecionado
  highlightSelectedElement(elementId) {
    if (!this.svgElement) return false;
    
    console.log('Highlighting element:', elementId);
    
    // Remover destaque anterior
    if (this.selectedElement) {
      console.log('Removing previous highlight from:', this.selectedElement.id);
      this.selectedElement.classList.remove('selected-highlight');
    }
    
    // Se um novo elemento foi selecionado
    if (elementId) {
      const element = this.svgElement.getElementById(elementId);
      if (element) {
        console.log('Adding highlight to:', elementId);
        element.classList.add('selected-highlight');
        this.selectedElement = element;
      } else {
        console.error('Element not found for highlighting:', elementId);
        this.selectedElement = null;
      }
    } else {
      this.selectedElement = null;
    }
    
    return true;
  }
}

// Exportar uma instância singleton
const svgManager = new SVGManager();
export default svgManager;

--- [8] src/store/LogoStore.jsx ---
// src/store/LogoStore.jsx
import { create } from 'zustand';
import colorManager from '../services/ColorManager';
import fontManager from '../services/FontManager';
import exportManager from '../services/ExportManager';
import svgManager from '../services/SVGManager';
import { getAllTemplates, loadTemplateContent } from '../utils/SVGTemplates';

const initialProjectState = {
  selectedLogoId: null,
  selectedElementId: null,
  svgContent: null, // Esta será a fonte da verdade para o SVG visual
  elements: new Map(), 
  textElements: [], 
  colorPalette: colorManager.colorSchemes['modern'] || Object.values(colorManager.getAllColorSchemes())[0], // Pega a primeira se 'modern' não existir
  transformations: new Map(),
  currentElementStyles: {}, // Para guardar estilos lidos do elemento selecionado
  // currentElementTransform já estava no Software_Architecture_Document.md, vamos usar 'transformations' Map
};

const useLogoStore = create((set, get) => ({
  currentScreen: 'selection',
  currentProject: { ...initialProjectState },
  history: { past: [], future: [] }, // P1

  setScreen: (screen) => set({ currentScreen: screen }),

  selectLogo: async (logoId) => {
    const template = getAllTemplates().find(t => t.id === logoId);
    if (!template) {
      console.error(`Template com id "${logoId}" não encontrado.`);
      return false;
    }
    try {
      const svgContent = await loadTemplateContent(logoId);
      if (!svgContent) throw new Error('Falha ao carregar SVG');
      
      const elementMap = await svgManager.parseSVGElements(svgContent);
      await fontManager.initialize(); // Garante que fontes P0 estejam prontas
      
      // Define uma paleta padrão se nenhuma estiver ativa (usando a nova estrutura do ColorManager)
      let activePalette = get().currentProject.colorPalette;
      if (!activePalette || Object.keys(activePalette).length === 0) {
        const schemes = colorManager.getAllColorSchemes(); // Objeto de esquemas
        const firstSchemeName = Object.keys(schemes)[0] || 'modern';
        colorManager.setActiveColorScheme(firstSchemeName);
        activePalette = colorManager.getActiveColorScheme().reduce((acc, color) => {
            acc[color.name.toLowerCase()] = color.hex; // primary, secondary, accent
            return acc;
        }, {});
      }

      set(state => ({
        currentScreen: 'editor',
        currentProject: {
          ...initialProjectState, // Reseta para o estado inicial do projeto
          selectedLogoId: logoId,
          svgContent, // Conteúdo SVG inicial do template
          elements: elementMap,
          colorPalette: activePalette, // Define a paleta
          transformations: new Map(), // Reseta transformações
          textElements: [], // Reseta textos
        }
      }));
      return true;
    } catch (error) {
      console.error('Erro ao carregar SVG do template:', error);
      return false;
    }
  },

  selectElement: (elementId) => {
    console.log('LogoStore: Selecting element', elementId);
    svgManager.highlightSelectedElement(elementId); // SVGManager cuida do visual
    
    if (elementId) {
      // Lê os estilos e transformações atuais do elemento SVG
      const styles = svgManager.getElementStyle(elementId);
      const transforms = svgManager.getElementTransform(elementId);
      
      console.log('Element styles:', styles);
      console.log('Element transforms:', transforms);
      
      const { currentProject } = get();
      const updatedTransformations = new Map(currentProject.transformations);
      
      // Garantir que temos um objeto de transformação válido
      const validTransforms = transforms || { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0 };
      updatedTransformations.set(elementId, validTransforms);

      set(state => ({
        currentProject: {
          ...state.currentProject,
          selectedElementId: elementId,
          currentElementStyles: styles || {},
          transformations: updatedTransformations,
        }
      }));
    } else {
      // Quando nenhum elemento é selecionado
      set(state => ({
        currentProject: {
          ...state.currentProject,
          selectedElementId: null,
          currentElementStyles: {},
          // Mantemos as transformações no Map para uso futuro
        }
      }));
    }
  },

  initElementTransform: (elementId) => {
    const { currentProject } = get();
    if (currentProject.transformations.has(elementId)) return;
    
    const existingTransform = svgManager.getElementTransform(elementId); // Tenta ler do SVG
    const defaultTransform = existingTransform || {
      translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0,
    };
    
    const updatedTransformations = new Map(currentProject.transformations);
    updatedTransformations.set(elementId, defaultTransform);
    set(state => ({
      currentProject: { ...state.currentProject, transformations: updatedTransformations }
    }));
  },

  updateElementTransform: (elementId, transformProps) => {
    const { currentProject } = get();
    let currentTransform = currentProject.transformations.get(elementId) || 
                           { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0 };
    
    const newTransform = { ...currentTransform, ...transformProps };
    
    // Passa os valores absolutos para o SVGManager
    svgManager.applyTransformation(elementId, {
      x: newTransform.translateX,
      y: newTransform.translateY,
      scaleX: newTransform.scaleX,
      scaleY: newTransform.scaleY,
      rotation: newTransform.rotation,
    });
    
    const newSvgString = svgManager.getSVGContent();
    const updatedTransformations = new Map(currentProject.transformations);
    updatedTransformations.set(elementId, newTransform);
    
    set(state => ({
      currentProject: {
        ...state.currentProject,
        transformations: updatedTransformations,
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
      }
    }));
  },

  updateElement: (elementId, properties) => { // Usado para estilos como fill, stroke, etc.
    const { currentProject } = get();
    // const element = currentProject.elements.get(elementId); // 'elements' Map é mais para dados iniciais/metadata
    // if (!element) return false;

    // Aplica diretamente via SVGManager
    svgManager.applyStyle(elementId, properties); 
    
    const newSvgString = svgManager.getSVGContent();
    const newCurrentStyles = { ...(currentProject.currentElementStyles || {}), ...properties };

    set(state => ({
      currentProject: {
        ...state.currentProject,
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
        currentElementStyles: state.currentProject.selectedElementId === elementId 
                              ? newCurrentStyles 
                              : state.currentProject.currentElementStyles,
        // Atualiza o 'elements' Map também se ele for usado para renderizar a UI
        // elements: new Map(currentProject.elements).set(elementId, { ...element, ...properties }) 
      }
    }));
  },
  
  applyColorPalette: (paletteIdOrObject) => {
    let paletteColors;
    let paletteToStore = {};

    if (typeof paletteIdOrObject === 'string') {
        const schemeName = paletteIdOrObject;
        colorManager.setActiveColorScheme(schemeName); // Define o esquema ativo no ColorManager
        const activeSchemeArray = colorManager.getActiveColorScheme(); // Retorna array de {name, hex, rgb}
        
        paletteColors = activeSchemeArray.reduce((acc, color) => {
            acc[color.name.toLowerCase()] = color.hex;
            return acc;
        }, {});
        paletteToStore = { id: schemeName, name: schemeName, ...paletteColors };

    } else if (typeof paletteIdOrObject === 'object') {
        paletteColors = { // Assume que o objeto tem primary, secondary, accent
            primary: paletteIdOrObject.primary,
            secondary: paletteIdOrObject.secondary,
            accent: paletteIdOrObject.accent,
        };
        paletteToStore = paletteIdOrObject;
    } else {
        console.error("Invalid palette data provided to applyColorPalette");
        return false;
    }
    
    const { currentProject } = get();
    // O método applyColorsToSVG do ColorManager espera o svgManager e o mapeamento de cores
    // Para P0, vamos simplificar. Assumimos que os SVGs têm classes:
    // .primary-color-element, .secondary-color-element, .accent-color-element
    // E que svgManager pode aplicar estilos a elementos por classe
    
    // Esta é uma implementação simplificada. Uma melhor abordagem seria o ColorManager
    // não manipular o DOM diretamente, mas retornar os seletores e cores, e o SVGManager aplicar.
    // Ou o SVGManager ter um método applyPalette(paletteConfig).
    if (svgManager.svgElement) { // Verifica se o SVG está inicializado
        const primaryElements = svgManager.svgElement.querySelectorAll('.primary-color-element');
        const secondaryElements = svgManager.svgElement.querySelectorAll('.secondary-color-element');
        const accentElements = svgManager.svgElement.querySelectorAll('.accent-color-element');

        primaryElements.forEach(el => svgManager.applyStyle(el.id, { fill: paletteColors.primary }));
        secondaryElements.forEach(el => svgManager.applyStyle(el.id, { fill: paletteColors.secondary }));
        accentElements.forEach(el => svgManager.applyStyle(el.id, { fill: paletteColors.accent }));
    }
    
    // Atualizar cor dos textos existentes
    const updatedTextElements = currentProject.textElements.map(textEl => {
      const newTextColor = colorManager.getTextColorForBackground(paletteColors.primary || '#FFFFFF');
      svgManager.updateTextElement(textEl.id, { fill: newTextColor });
      return { ...textEl, fill: newTextColor };
    });

    const newSvgString = svgManager.getSVGContent();
    set(state => ({
      currentProject: {
        ...state.currentProject,
        colorPalette: paletteToStore,
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
        textElements: updatedTextElements,
        // elements: new Map(currentProject.elements) // Precisa atualizar o 'elements' Map também
      }
    }));
  },
  
  addTextElement: async (textProps) => {
    await fontManager.initialize(); // Garante que as fontes P0 estejam carregadas
    const defaultFont = fontManager.getAvailableFonts().length > 0 ? fontManager.getAvailableFonts()[0].family : 'Arial';
    
    const finalFontFamily = textProps.fontFamily || defaultFont;
    await fontManager.loadFont(finalFontFamily); // Carrega a fonte específica
    
    const { currentProject } = get();
    const finalFillColor = textProps.fill || colorManager.getTextColorForBackground(currentProject.colorPalette.primary || '#FFFFFF');
    
    const id = `text-${Date.now()}`;
    const textElementData = {
      id,
      type: textProps.type || 'companyName',
      content: textProps.content,
      fontFamily: finalFontFamily,
      fontSize: textProps.fontSize || 24,
      fontWeight: textProps.fontWeight || '400',
      fill: finalFillColor,
      position: textProps.position || { x: 200, y: 350 }, // P0 default
      alignment: textProps.alignment || 'middle', // P0 default
    };
    
    svgManager.addTextElement(textElementData);
    const newSvgString = svgManager.getSVGContent();
    
    set(state => ({
      currentProject: {
        ...state.currentProject,
        textElements: [...state.currentProject.textElements, textElementData],
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
      }
    }));
    return id;
  },
  
  updateTextElement: async (textId, properties) => {
    const { currentProject } = get();
    const textElement = currentProject.textElements.find(el => el.id === textId);
    if (!textElement) return false;

    if (properties.fontFamily) {
      await fontManager.loadFont(properties.fontFamily);
    }
    
    svgManager.updateTextElement(textId, properties);
    const newSvgString = svgManager.getSVGContent();
    
    set(state => ({
      currentProject: {
        ...state.currentProject,
        textElements: state.currentProject.textElements.map(el => 
          el.id === textId ? { ...el, ...properties } : el
        ),
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
      }
    }));
    return true;
  },

  deleteTextElement: (textId) => {
    svgManager.removeTextElement(textId);
    const newSvgString = svgManager.getSVGContent();
    set(state => ({
      currentProject: {
        ...state.currentProject,
        textElements: state.currentProject.textElements.filter(el => el.id !== textId),
        selectedElementId: state.currentProject.selectedElementId === textId ? null : state.currentProject.selectedElementId,
        svgContent: newSvgString, // ATUALIZA O SVG CONTENT
      }
    }));
  },

  exportLogo: async (format, resolution = 1, filename = 'logo') => { // Adicionado filename
    const { svgContent } = get().currentProject;
    if (!svgContent) {
      alert("Nenhum logo para exportar.");
      console.error("LogoStore: Nenhum svgContent para exportar.");
      return null;
    }
    
    try {
      if (format === 'svg') {
        return exportManager.exportSVG(svgContent, `${filename}.svg`);
      } else if (format === 'png') {
        return await exportManager.exportPNG(svgContent, `${filename}.png`, resolution);
      } else {
        throw new Error(`Formato de exportação não suportado: ${format}`);
      }
    } catch (error) {
      console.error('LogoStore: Erro na exportação:', error);
      alert(`Erro ao exportar como ${format.toUpperCase()}. Verifique o console.`);
      return null;
    }
  }
}));

export default useLogoStore;

